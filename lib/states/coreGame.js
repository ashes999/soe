// Generated by CoffeeScript 1.8.0
(function() {
  window.CoreGame = (function() {
    var PLAYER_FRAME_RATE, PLAYER_MOVE_SPEED, TILE_SIZE;

    function CoreGame() {}

    PLAYER_MOVE_SPEED = 256;

    PLAYER_FRAME_RATE = 6;

    TILE_SIZE = {
      width: 32,
      height: 32
    };

    CoreGame.prototype.create = function() {
      var startX, startY;
      this._showMap(this.game.data.world.currentMap);
      this.game.physics.startSystem(Phaser.Physics.ARCADE);
      startX = this.currentMap.startX || this.game.world.centerX;
      startY = this.currentMap.startY || this.game.world.centerY;
      this.player = this.game.add.sprite(startX, startY, 'hero 1');
      this.player.animations.add('down', [0, 1, 2], PLAYER_FRAME_RATE, true);
      this.player.animations.add('left', [3, 4, 5], PLAYER_FRAME_RATE, true);
      this.player.animations.add('right', [6, 7, 8], PLAYER_FRAME_RATE, true);
      this.player.animations.add('up', [9, 10, 11], PLAYER_FRAME_RATE, true);
      this.game.physics.enable(this.player, Phaser.Physics.ARCADE);
      this.game.camera.follow(this.player);
      return this.cursors = this.game.input.keyboard.createCursorKeys();
    };

    CoreGame.prototype.update = function() {
      if (this.cursors.left.isDown) {
        this.player.body.velocity.x = -1 * PLAYER_MOVE_SPEED;
        this.player.animations.play('left');
      } else if (this.cursors.right.isDown) {
        this.player.body.velocity.x = PLAYER_MOVE_SPEED;
        this.player.animations.play('right');
      } else {
        this.player.body.velocity.x = 0;
      }
      if (this.cursors.up.isDown) {
        this.player.body.velocity.y = -1 * PLAYER_MOVE_SPEED;
        this.player.animations.play('up');
      } else if (this.cursors.down.isDown) {
        this.player.body.velocity.y = PLAYER_MOVE_SPEED;
        this.player.animations.play('down');
      } else {
        this.player.body.velocity.y = 0;
      }
      if (!(this.cursors.up.isDown || this.cursors.down.isDown || this.cursors.left.isDown || this.cursors.right.isDown)) {
        this.player.animations.stop();
      }
      this.game.physics.arcade.collide(this.player, this.collideTiles);
      return this.game.physics.arcade.overlap(this.player, this.transitionTiles, this._checkAndTransitionPlayer, null, this);
    };

    CoreGame.prototype._showMap = function(map) {
      var t, tile, tiles, x, y, _i, _j, _k, _len, _ref, _ref1, _ref2, _results;
      this.currentMap = map;
      if (this.transitionTiles != null) {
        this.transitionTiles.destroy;
      }
      if (this.collideTiles != null) {
        this.collideTiles.destroy;
      }
      if (this.tiles != null) {
        this.tiles.destroy;
      }
      this.collideTiles = this.game.add.group();
      this.collideTiles.enableBody = true;
      this.tiles = this.game.add.group();
      this.transitionTiles = this.game.add.group();
      for (y = _i = 0, _ref = map.height; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        for (x = _j = 0, _ref1 = map.width; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          tile = this.game.add.sprite(game.world.centerX, game.world.centerY, 'top outside tiles');
          tile.x = x * TILE_SIZE.width;
          tile.y = y * TILE_SIZE.height;
          tile.frame = map.get(x, y);
          if (tile.frame > 0) {
            tile.frame = 1;
            this.game.physics.enable(tile, Phaser.Physics.ARCADE);
            this.collideTiles.add(tile);
            tile.body.immovable = true;
          } else {
            this.tiles.add(tile);
          }
        }
      }
      _ref2 = map.transitions;
      _results = [];
      for (_k = 0, _len = _ref2.length; _k < _len; _k++) {
        t = _ref2[_k];
        tiles = this.tiles.filter(function(sprite, index, tiles) {
          this.tiles = tiles;
          return sprite.x === t.x * TILE_SIZE.width && sprite.y === t.y * TILE_SIZE.height;
        });
        if (tiles.total === 0) {
          tiles = this.transitionTiles.filter(function(sprite, index, transitionTiles) {
            this.transitionTiles = transitionTiles;
            return sprite.x === t.x * TILE_SIZE.width && sprite.y === t.y * TILE_SIZE.height;
          });
        }
        if (tiles.total === 0) {
          throw "Found no tiles at " + t.x + ", " + t.y;
        }
        tile = tiles.first;
        this.game.physics.enable(tile, Phaser.Physics.ARCADE);
        this.transitionTiles.add(tile);
        _results.push(tile.body.immovable = true);
      }
      return _results;
    };

    CoreGame.prototype._checkAndTransitionPlayer = function(player, tile) {
      var playerX, playerY, t;
      t = this.currentMap.transitionAt(tile.x / TILE_SIZE.width, tile.y / TILE_SIZE.height);
      if (t == null) {
        throw "Can't find transition at " + (tile.x / TILE_SIZE.width) + ", " + (tile.y / TILE_SIZE.height);
      }
      if (t.destination === this.currentMap) {
        throw 'Transition from map to itself';
      }
      this.game.data.world.currentMap = t.destination;
      playerX = t.destX * TILE_SIZE.width;
      if (t.direction === 'right') {
        playerX += TILE_SIZE.width;
      }
      if (t.direction === 'left') {
        playerX -= TILE_SIZE.width;
      }
      playerY = t.destY * TILE_SIZE.height;
      if (t.direction === 'down') {
        playerY += TILE_SIZE.height;
      }
      if (t.direction === 'up') {
        playerY -= TILE_SIZE.height;
      }
      t.destination.startX = playerX;
      t.destination.startY = playerY;
      return this.game.state.start('coreGame');
    };

    return CoreGame;

  })();

}).call(this);
